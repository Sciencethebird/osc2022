#include <stdint.h>
#include "exception.h"
#include "thread.h" 
#include "io.h"
#include "mini_uart.h"
#include "timer.h"
#include "printf.h"
#include "utils.h"

int count = 0;

void enable_interrupt() { asm volatile("msr DAIFClr, 0xf"); }

void disable_interrupt() { asm volatile("msr DAIFSet, 0xf"); }

void sync_handler() { 
  // handles exception generated by user commadn
  // , for example 'svc'
  uint64_t spsr_el1, elr_el1, esr_el1;
  asm volatile("mrs %0, spsr_el1" : "=r"(spsr_el1));
  asm volatile("mrs %0, elr_el1" : "=r"(elr_el1));
  asm volatile("mrs %0, esr_el1" : "=r"(esr_el1));
  print_s("SPSR_EL1: ");
  print_h(spsr_el1);
  print_s("\n");
  print_s("ELR_EL1: ");
  print_h(elr_el1); // return address of EL1 exception
  print_s("\n");
  print_s("ESR_EL1: "); 
  print_h(esr_el1); // cause of the exception
  print_s("\n\n");
  while(1){}
}

void lower_64_EL_sync_handler(uint64_t sp){
  // exception registor
  uint64_t spsr_el1, elr_el1, esr_el1;
  asm volatile("mrs %0, spsr_el1" : "=r"(spsr_el1));
  asm volatile("mrs %0, elr_el1" : "=r"(elr_el1));
  asm volatile("mrs %0, esr_el1" : "=r"(esr_el1));
  asm volatile("mrs %0, esr_el1" : "=r"(esr_el1));
  // https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Registers/ESR-EL1--Exception-Syndrome-Register--EL1-
  int ec = (esr_el1 >> 26) & 0x3f; // exception class
  //int iss = esr_el1 & ((1 << 25) - 1); // [24:0], instruction specific syndrome {svc <iss>}

  if(ec == 0b010101){
    // according the lab spec, the number of the systme call is store in x8
    trap_frame_t *trap_frame = (trap_frame_t *)sp;
    int sys_call_num;
    asm volatile("mov %0, x8" : "=r"(sys_call_num));

    //print_s("system call number: ");
    //print_i(sys_call_num);
    //print_s("\r\n");

    // print content of the trap frame
    //for(int i = 0; i< 10; i++){
    //  print_s("trap frame ");
    //  print_i(i);
    //  print_s(", ");
    //  print_i(trap_frame->x[i]);
    //  print_s("\r\n");
    //}

    //delay(5000000);

    if(sys_call_num == 0){ // int getpid()
      uint32_t pid = get_current()->pid;
      asm volatile("mov x0, %0" : "=r"(pid)); // function reture value
    }else if(sys_call_num == 1){ // uart_read(char buf[], size_t size)
      char *str = (char *)(trap_frame->x[0]);
      uint32_t size = (uint32_t)(trap_frame->x[1]);
      size = uart_gets(str, size);
      trap_frame->x[0] = size;
    }else if(sys_call_num == 2){ // uartread(char buf[], size_t size)
      char* str = (char*) trap_frame->x[0];
      uint32_t size = (uint32_t)(trap_frame->x[1]);
      //uart_puts("[size: ");
      //print_i(size);
      //uart_puts(", ");
      uart_write(str, size);  
      //uart_puts(":");
      //for(int i = 0; i< size; i++){
      //  print_i(str[i]);
      //}
      //uart_puts("]\n");
    }else if(sys_call_num == 3){
      print_s("exec called\r\n");
      //char *program_name = (char *)trap_frame->x[0];
      //const char **argv = (const char **)trap_frame->x[1];
      exec();
    }else if(sys_call_num == 4){
      print_s("fork called\r\n");
      fork(sp);
    }else if(sys_call_num == 5){
      print_s("exit called\r\n");
    }else if(sys_call_num == 6){
      print_s("mbox_call called\r\n");
    }else if(sys_call_num == 7){
      print_s("kill called\r\n");
    }else{
      print_s("unhandled system call number\r\n");
    }
  }

      //
  //if(ec == 0b010101){
  //  trap_frame_t *trap_frame = (trap_frame_t *)sp;
  //  int sys_call_num = trap_frame->x[8];
  //  if(sys_call_num == 0){
  //    print_s("x8: ");
  //    print_i(trap_frame->x[8]);
  //    print_s("\r\n");
  //    print_s("get pid\r\n");
  //    uint32_t pid = get_current()->pid;
  //    trap_frame->x[0] = pid;
  //  }else  if(sys_call_num <10){
  //    print_s("x8: ");
  //  print_i(trap_frame->x[8]);
  //  print_s("\r\n");
  //  }
  //
  //}
  //
//
  //
  ////for(int i = 0; i<32; i++){
  ////  print_s("x");
  ////  print_i(i);
  ////  print_s(": ");
  ////  print_i()
  ////  print_s("x")
  ////  print_s("x")
  ////}
}

// user timer handler
void el0_to_el1_irq_handler() {
  disable_interrupt();
  uint32_t is_uart = (*IRQ_PENDING_1 & AUX_IRQ);

  if (is_uart) {
    uart_handler();
  } else {
    core_timer_handler(); 
  }
  enable_interrupt();
}

// kernel timer handler
uint64_t el1_to_el1_irq_handler(uint64_t sp) {

  disable_interrupt();
  uint32_t is_uart = (*IRQ_PENDING_1 & AUX_IRQ);
  uint32_t is_core_timer = 1;
  if (is_uart) {
    uart_handler();
  } else if(is_core_timer){
    ////print_s("timer handler\r\n");
    //// core_timer_handler();
    //
    ////timeout_event_handler(); 
    //// timeout event does not work with timer schedular, temp ignored this function.
    //exception_frame_t* exception_context = (exception_frame_t*) sp;
    //if(from_kernel == 0){
    //  printf("saving context\r");
    //  save_thread_info(exception_context);
    //  //from_kernel = 0;
    //}else{
    //  from_kernel = 0;
    //}
    //print_s("\r\n=================\r\npid stack: ");
    //print_i( ((thread_info*)exception_context->tpidr_el1)->pid);
    //printf("tpid location: %d\n", exception_context->tpidr_el1);
    ////print_s("\r\n");
    //timer_schedular_handler();
    //if(run_queue.head != 0){
    //  if(run_queue.head->context.lr == 0){
    //    printf("lr == 0!!!\n");
    //  }else{
    //    load_thread_info(run_queue.head, exception_context);
    //    //print_s("\r\n======================================\r\n");
    //    print_s("pid: ");
    //    print_i( ((thread_info*)exception_context->tpidr_el1)->pid);
    //    print_s("\r\nrun_queue.head: ");
    //    print_i(run_queue.head);
    //    print_s("\r\n");
    //  }
    //}else{
    //  printf("nononononono\n");
    //}
    ////print_s("pid: ");
    ////print_i(get_current());
    ////print_s("\r\n");
    kill_zombies();
    handle_fork();
    ////schedule();
    //plan_next_interrupt_sec(1);
    plan_next_interrupt_tval(SCHEDULE_TVAL);
    
    schedule();
  }
  //plan_next_interrupt_tval(SCHEDULE_TVAL);
  enable_interrupt();
  return sp;
}


//void irq_handler2() {
//  disable_interrupt();
//  uint32_t is_uart = (*IRQ_PENDING_1 & AUX_IRQ);
//
//  if (is_uart) {
//    uart_handler();
//  } else {
//    print_s("irq_handler2!!!!");
//    core_timer_handler();
//  }
//  enable_interrupt();
//}

void default_handler() { print_s("===== default handler =====\n"); }